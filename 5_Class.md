5. 클래스(Class)
- 클래스
    - '이 데이터들은 함께 사용되는데, 그에 관련된 로직이 이것이다'라는 이야기를 하고 싶을 때 클래스를 사용한다
    - 클래스를 사용하는 이유는 데이터가 로직에 비해 빈번하게 변화하기 때문이다
    - 다른 클래스의 크기를 너무 비대하게 하지 않으면서 클래스위 수를 줄이는 것이 프로그램 개선이다

- 단순한 상위 클래스 이름 
    - 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다

- 한정적 하위 클래스 이름 
    - 상위클래스와 유사점과 차이점을 분명히 드러내느 이름을 사용한다
    - 간결성을 포기하고 표현성을 택하는 편이 낫다
    - 보통 상위 클래스에 한 두개의 수식어를 붙여서 만든다
    - 클래스의 이름은 코드의 내용을 반영해야 한다

- 추상 인터페이스 
    - 인터페이스와 구현을 분리한다
    - 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야 한다

- 인터페이스 
    - 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다
    - 인터페이스 사용은 '여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다'라고 말하는 것과 같다
    - 인터페이스를 사용하면 구현을 바꾸는 것은 쉽지만, 인터페이스 자체를 바꾸기는 쉽지 않다
    - 인터페이스를 사용해서 커뮤니케이션에 방해가 되는 한가지 요인은 모든 연산이 공용이어야 한다는 점이다
    - 클래스와 동일한 방법으로 작명하거나 'I"를 붙여서 작명한다

- 추상 클래스 
    - 자주 바귈 것 같은 추상 인터페이스에는 추상 클래스를 사용한다
    - 추상 인터페이스(abstract interface)와 실제 구현의 차이를 나타내는 다른 방법은 상위클래스를 사용하는 것이다
    - 각 클래스가 단 1개의 상위 클래스만을 지정할 수 있다는 것이 단점이다

- 중요!!
- 인터페이스 -> '이 기능은 이렇게 사용하세요!' 라고 전달 하는 것
- 상위클래스 -> '이 기능은 이렇게 구현 해봤습니다!' 라고 전달 하는 것


- 버전 인터페이스 
    - 하위인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다
    - 새로운 인터페이스를 선언해서 기존 인터페이스를 확장(상속)한 후 새로운 연산을 추가할 수 있다
    - 새로운 연산을 사용하는 경우, 반드시 객체의 타입을 확인한 후 새로운 타입으로 다운캐스트해서 사용해야 한다
```java
interface Command {}
    void run();
}
interface ReversibleCommand extends Command {
    void undo();
}
class Main { // 다운캐스트
    public static void main(String[] args){
        Command recent = Command();
        if(recent instanceof ReversibleCommand){
            ReversibleCommand downcasted = (ReversibleCommand) recent;
            downcasted.und();
        }
    }
}
```
    - 보통 instanceof를 사용하는 경우, 코드가 특정 클래스에 제한되므로 유연성이 떨어진다
      하지만 인터페이스를 개선할 수 있었으므로 instanceof의 사용이 정당화 된다
    - 버전 인터페이스를 많이 사용 하게 된다는 것은 설계를 수정해야 할 때가 됬다는 뜻이다

- 값 객체 
    - 산술 값처럼 동작하는 객체를 사용한다
    - FP스타일 연산은 상태를 변화시키지 않으며 새로운 값을 생성한다. 일시적이라도 고정적인 상확을 표현하고 싶다면
      함수형 스타일이 적절하고, 상황이 변하는 경우라면 상태(state)를 사용 편이 낫다

- 특화 
    - 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다
    - 연산 간의 유사점과 차이점을 부각시키는 방향으로 코드를 작성하면, 프로그램을 읽고 사용하고 수정하기 쉬워진다

- 하위 클래스 
    - 1차원적 변화는 하위 클래스를 사용해서 표현 한다
    - '이 부분만 제외하면 상위 클래스와 같다'는 뜻

- 구현자 
    - 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다
    - 코드의 목적에 부합하게 구현된 경우, 이 연산의 내부 구현에 대해서는 신경쓰지 않아도 괜찮다는 뜻

- 내부 클래스 
    - 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다
    - 작은 전용 클래스를 사용하면 클래스 사용에 따른 비용을 지불하지 않으면서도 클래스의 장점을 대부분 취할 수 있다
    - 내부 클래스는 외부 클래스의 정보를 암묵적으로 전달 받는다
```java
public class InnerClassExample {
    private String field;
    public class Inner { // 인자 없는 생성자를 가질 수 없다
        public String example(){
            return field;   //감싼 클래스 인스턴스의 필드를 사용
        }
    }
    @Test public void passes(){
        field = "abc";
        Inner bar = new Inner();
        assertEquals("abc", bar.exmaple());
    }
}
```
- 인스턴스별 행위 
    - 인스턴스에 따라 로직에 변화를 준다
    - 객체의 로직이 클래스에 의해 완전히 정의될 떄, 코드 독자는 코드를 읽고 어떤 일이 벌어지는지 이해한다
    - 하지만 인스턴스 별로 다른 행동을 보이는 경우, 인스턴스의 행동을 이해하기 위해서는 흐름을 분석해야만 한다

- 조건문 
    - 명시적 조건에 따라 로직에 변화를 준다
    - 조건문을 사용하게 되면 데이터에 따라 각 인스턴스는 다른 로직을 수행하게 된다
    - 조건문의 장점은 인스턴스별 행동을 지원하면서도 모든 로직이나 하나의 클래스 안에 들어있다는 것이다
    - 그러나 조건문을 사용하면 인스턴스 행동을 변경하기 위해 해당 클래스 코드를 고쳐야만 한다
    - 하위 클래스를 사용하던지 아니면 위임을 사용해서 위 문제를 해결할 수 있다

- 위임 
    - 여러 종류의 객체 중 하나에 위임해서 로직에 변화를 준다
    - 각 인스턴스에서 다른 로직을 수행하도록 하는 방법 중 하나
    - 공통으로 사용되는 로직은 위임 클래스를 참조하는 클래스에 들어 있지만, 변형은 여러 객체에 각각 구현된다
```java
public void mouseDown(){
    switch(getTool(){
        case SELECTING : 
            break;
        case CREATIING_RECTANGEL :
            break;
    })
}
//개선 (위임사용) -> switch 구문 안에 있던 내용들이 여러 도구 관련 클래스로 옮겨졌다
public void mouseDown(){
    getTool().mouseDown(this);
}

// GraphicEditor
public void mouseDown(){
    tool.mouseDown();
}
// RectangleTool
private GraphicEditor editor;
public RectangleTool(GraphicEditor editor){
    this.editor = editor;
}
public void mouseDown(){
    editor.add(new RactangleFigure());
}
```

- 플러그인 선택자 
    - 리플렉션을 이용한 메소드 호출로 로직에 변화를 준다
    - 한두 개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스안에 들어가도 좋은 경우
    - 인스턴스별 행동을 위해 자바가 지원하는 방법중 하나

- 익명 내부 클래스 
    - 필요한 메소드에서 한두 개의 메소드만 오버라이드하는 객체를 만들어서 사용한다
    - 인스턴스별 행동을 위해 자바가 지원하는 방법중 하나
    - 한 곳에서만 사용되는 클래스를 생성해서 일부 메소드를 오버라이드한 후, 지역적으로 사용 하는 것
    - 상위 클래스가 대부분의 구현을 담당하고 있어서 내부 클래스를 쉽게 구현 할 수 있을 경우에 좋다

- 라이브러리 클래스 
    - 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다
    - 어떤 객체에도 적합하지 않은 기능은 빈 클래스를 하나 만들어서 정적 메소드로 구현 하는 것이다
    - 라이브러리 클래스는 인스턴스화가 불가능한, 라이브러리 메소드만을 갖고 있는 클래스 이다
    - 가능한 경우 라이브러리 클래스는 객체로 변환하는 것이 좋다 (정적 메소드를 인스턴스로 메소드로 바꾸면 된다)
