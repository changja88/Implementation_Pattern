8. 메소드
- 로직은 하나의 덩어리가 아닌 여러 개의 메소드로 구성된다
- 프로그램 로직을 여러 개의 메소드로 나누면 로직 간의 연관성을 나타낼 수 있다
- 메소드 이름을 통해 독자는 실제 세부 구현과 상관 없이 로직의 목적이 무엇인지 알 수 있다
- 어떻게 메소드를 잘 만들지 알기 위해서는 경험이 필요하다
- 메소드 관련 패턴은 다음과 같다

1. 조합 메소드 
    - 다른 메소드에 대한 호출로 메소드를 작성한다
    - 추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성하라
    ```java
    void compute() {
        input();
        flags |= 0x0080; // 갑자기 비트 연산이 나오면 흐름이 깨진다
        output();
    }
    ```
    - 메소드를 독자가 이해 하기 쉽도록 잘 쪼개 노아라
    - 일단 동작하는 코드를 만들고 구성 방식을 결정하라

2. 의도 제시형 이름
    - 메소드가 의도하는 바를 나타내는 이름을 사용한다
    - 메소드 사용자는 메소드 이름을 통해 메소드의 의도를 쉽게 파악할 수 있어야 한다
    - 의도 외의 다른 것들(구현 전략 등등)은 다른 방식으로 전달하는 것이 좋다
    ```java
    Customer.linearCustomerSearch(String id) // 이렇게 작성하지마라 독자는 선형으로 찾는지 관심이 없다
    Customer.find(String id) // 좋음 
    Customer.fastFind(String id) // 좋음
    // 메소드의 이름을 지을 때는 그 메소드를 호출하는 입장에서 생각해라
    ```
    - 왜 이 메소드를 사용해야 하는가? 에 답을 메소드 이름에서 찾을 수 있어야 한다

3. 메소드 가시성
    - 메소드는 가급적 전용으로 한다
    - 메소드 가시성에 있어 상충하는 두 가지 주요 요소는 외부 사용자에게 기능을 노출시켜야 하는 것과 미래 수정에 대한 유연성이다
      더 많은 기능을 노출 시킬 수록 객체에 대한 인터페이스를 수정하기는 어려워진다
    - 공용 (public)
        - 프로그래머가 코드 관리를 책임 지겠다는 듯, 모든 수정을 담당하거나, 최소한 수정사항을 알려줄 책임이 있다
    - 패키지 (default)
        - 패키지로 가시성을 설정했다면, 전용으로 구현이 가능한지 아니면 더 널리 유용하게(공용) 으로 만들수 있는지 고려해야한다
    - 보호 (Protected)
        - 하위클래스를 사용해서 코드를 재사용하려 할 때 유용하다
    - 전용 (Private)
        - 전용 메소드는 최고의 유연성을 확보해준다
    - 가장 제한적인 가시성을 선택한 후, 필요에 따라 조금씩 가시성을 높여라

4. 메소드 객체
    - 복잡한 메소드는 새로운 객체로 바꾼다
    - 이 패턴은 보통 동작하는 코드가 나온 후에 사용하는 것이 보통이며, 코드가 복잡할수록 효과가 크다
    - 1. 메소드 이름을 따서 클래스 이름을 정한다 (complexCalculation() 은 ComplexCalculator 가 된다)
    - 2. 메소드에서 사용하는 각 파라미터, 지역변수, 필드에 대해 새로운 객체상의 필드를 생성한다
         일단 기존에 사용한 이름과 같은 이름을 사용한다
    - 3. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다
    - 4. 본래 메소드를 새로운 클래스의 calculate()라는 메소드로 복사한다
         기존 메소드에서 파라미터, 지역변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 되었다
    - 5. 기존 메소드의 본문을 새로운 객체의 인스턴스 생성한 후 calculate()를 호출하는 코드로 바꾸다
    ```java
    complexCalculation(){
        new ComplexCalculator().calculate();
    }
    ```
    - 6. 본래 메소드에서 필드를 설정하는 부분이 있었다면, 다음과 같이 calculate() 가 반환된 후에 설정해준다
    ```java
    complexCalculation(){
        ComplexCalculator calculator = new ComplexCalculator();
        calculator.calculate();
        mean = calculator.mean;
        variance = calculator.variance;
    }
    ```

5. 오버라이드 메소드
    - 특화를 나타내기 위해 오버라이들 사용한다
    - 상위 클래스에서 메소드를 abstract로 선언했다면 이는 하위 클래스에서 연산을 특화하라는 뜻이다
    - 하지만 final 메소드만 아니면 기존 연산에 대한 변형을 표현할 수 있다
    - 오버라이드를 한다고해서 상위 클래스와 하위 클래스 의 메소드중 하나를 선택 해야 하는 것은 아니다
      super.method();를 호출해서 상위 클래스의 메소드를 사용할 수 있다
    - 상위 클래스의 메소드를 호출하는 곳은 같은 이름을 가지고 있는 메소드 안에서만 하는 것이 좋다

6. 오버로드 메소드
    - 같은 연산에 대해 다른 인터페이스를 제공한다
    - 서로다른 파라미터를 사용해서 같은 메소드를 선언하면 '이 메소드를 사용 할 수 있는 다양한 포맷이 존재한다'라는 의미다
    - 메소드 오버로드는 파라미터 타입만 다를 뿐, 같은 연산을 수행해야 한다

7. 메소드 반환 타입
    - 반환 타입에는 가급적 가장 일반적인 타입을 사용한다
    - 가급적 메소드의 적용 범위를 넓히기 위해서 의도를 드럴낼 수 있는 가장 추상적인 타입을 사용해라
    - 반환 타입을 일반화하면 세부 구현을 숨길 수도 있다

8. 메소드 주석
    - 코드 자체에서 쉽게 얻을 수 없는 정보는 주석을 통해 나타낸다
    - 메소드 주석이 커뮤니케이션에 도움이 되는 최상의 선택이라면 좋은 주석을 작성하라

9. 도우미 메소드
    - 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용한다
    - 긴 메소드를 여러 개의 작은 메소드로 나누게 되면 짧은 도우미 메소드가 필요하다
    - 도우미 메소드의 목적은 당장 관련도가 떨어지는 세부 구현을 숨기고 메소드 이름을 통해 프로그래머의 의도를 나타냄으로써, 복잡하고 거대한 연산코드를 좀더 읽기 좋게 하기 위함이다

10. 디버그 출력 메소드
    - toString() 을 사용해서 유용한 디버그 관련 정보를 출력한다
    - toString()은 프로그래머에게 유용한 객체의 정보를 알려주기 위해서 사용하는 것이 좋다 
      그 밖의 문자열 정보는 다른 메소드나 다른 클래스를 통해 표현해라

11. 변환
    - 객체 형변환은 명확하게 표현한다
    - 변환을 편리하게 표현하기 위해 새로운 의존성을 만들면 안된다

12. 변환 메소드
    - 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공한다
    - 유사한 타입의 객체 간 변환을 표현하려 하고 필요한 변환의 수에 제한이 있다면,
      기존 객체에 메소드를 축해서 변환을 나타낼 수 있다
    ```java
    class polar {
        Cartesian ascartesian(){

        }
    }
    ```
    - 변환을 사용하는 이유는 다른 프로토콜을 사용하는 개체를 얻기 위함이다
    - 이 방법은 읽기 쉬워서 많이 사용되자만, 원복 객체와 대상 객체 사이에 의존성을 생성하게 된다
    - 이러한 단점들로 변환 메소드는 자주 사용되지 않으며, 유사한 타입의 객체 사이의 변환에만 사용한다

13. 변환 생성자
    - 대부분의 변환에 대해서는 원본 객체를 인자로 취하는 변환될 객체의 생성자를 제공한다
    - 변환 생성자는 원본 객체를 파라미터로 취해서 대상 객체를 반환한다
    - 하나의 원본 객체를 여러 다른 대상 객체로 변환할 때 유용하다

14. 생성
    - 객체 생성을 명확히 표현한다
    - 의미 있는 개체 생성을 위해서는 명확하고 직접적인 표현과 유연성 사이에서 균형을 잡아야 한다

15. 완결 생성자 (그냥 일반 생성자)
    - 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다
    - 객체는 연산을 하기위해 정보를 필요로 한다. 생성자에서 연산을 할 수 있는 객체를 반환하도록 해서
      잠재적 사용자들에게 연산을 위한 선결 조건을 전달해야 한다
    - 완결 생성자를 구현할 때는 모든 생성자가 동일한 하나의 생성자를 사용해서 모든 초기화를 하도록 해야한다
      그래야 어떤 생성자를 사용하더라도 클래스의 올바른 동작을 위해 필요한 변치 않는 부분을 적절히 설정 할 는 것을 보장 할 수 있다

16. 공장 메소드
    - 좀더 복잡한 객체를 생성할 때, 생성자 대신 정적 메소드를 사용한다
    - 추상 타입을 반환할 수 있으며, 의도가 담긴 별도의 이름을 가질 수 있다 -> 복잡성 증가
    - 평범한 객체 생성을 하는 경우에는 완결 생성자를 사용하고, 객체 생성 이외의 다른 의도가 있는 경우에만 공장 메소드를 사용해라

17. 내부 공장
    - 좀더 많은 설명이 필요하거나 이후 개선이 필요한 객체 생성의 경우 도우미 메소드로 캡슐화 한다
    - 객체 생성과정이 복잡하거나 하위클래스에 따라 달라질 경우, 새로운 객체를 생성하고 반환하는 메소드를 만드는 것이 좋다
    - 내부 공장은 게이른 초기화를 사용하는 경우 흔히 사용되는 패턴이다
    ```java
    getX(){ // 너무 많은 내용을 전달한다
        if( x == null)
            x= ...;
        return x;
    }

    getX(){ // 변수 x에 대한 연산이 복잡한 경우에는 내부 공장을 사용하는 것이 좋다
        if( x== null)
            x = computeX();
        return x;
    }
    ```

18. 컬렉션 접근 메소드
    - 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공한다
    ```java
    List<Book> getBooks(){
        return books
    }
    // 이런식으로 그냥 줘버리면 사용자가 컬렉션을 직접 조작하게 되므로, 
    // 컬렉션 데이터에 의존적인 객체 내부 상태가 유효하지 않을수 있게 된다
    ```
    - 수정할 수 없는 컬렉션 형태로 바꿔서 반환하는 방법
    ```java
    List<Book> getBooks(){
        return Collections.unmodifiableList(books);
    }
    // 누군가 컬렉션을 수정하려고 하면 예외가 발생하는데, 디버깅 하는데 비용이 많이 드는 문제점이 있따
    ```
    - 제한적이지만 의미있는 접근을 제공해야 한다
    ```java
    void addBook(Book arrival){
        books.add(arrival);
    }
    int bookCount() {
        return books.size();
    }
    // 사용자가 컬렉션 원소를 하나씩 접근해야 한다면, 순차 반환 메소드를 제공
    Iterator getBooks(){
        return books.iterator();
    }
    ```
    - 그냥 클라이언트가 컬렉션을 통해서 하고 싶을 것 같은 작업들을 메소드로 제공해줘라

19. 불린 설정 메소드
    - 커뮤니케이션에 도움이 된다면, 불린 값을 설정하는 두개(상태별로 하나씩)의 메소드를 제공한다
    ```java
    void setValid(boolean newState){
    }

    void valid(){}
    void invalid(){}
    ```
20. 질의 메소드
    - 때로 객체는 다른 객체의 상태에 따라 결정을 내려야 한다
    - 객체가 프로토콜을 통해 다른 객체의 결정을 도와야 할 경우에는 'be동사'나 'have'동사를 사용해라
    ```java
    if(widget.isVisible())
    ```

21. 동등성 메소드
    - 객체의 동일성이 아닌 동등성(equality)를 비교해야 하는 경우, equals(), hashCode()를 구현하라
    - 동등한 객체는 같은 해쉬 값을 가져야하므로, hashCode()의 구현에는 equals()구현에 쓰인 데이터만을 사용해야한다
    ```java
    public boolean equals(Object other){
        if(!other instanceof Instrument)
            return false;
        Instrument istrument = (Instrument) other;
        return getSerialNumber().equals(instrument.getSerialNumber());
    }
    public int hashCode(){ 
        // 동등성 비교에 사용되느 ㄴ정보는 시리얼 넘버뿐이므로, 해쉬 값을 구할 때도 시리얼 넘버만 사용해야 한다
        return getSerialiNumber.hashCode();
    }
    ```
    - 2개의 수정 불가능한(immutable)객체가 동등하다면 둘은 언제나 같은 객체임을 보장해주는 기법을 쓸수도 있다
    ```java
    static Instrument create(String serialNumber){
        if(cache.containsKey(serialNumber))
            return cache.get(serialNumber);
        Instrument result = new Instrument(serialNumber);
        cache.put(serialNumber, result);
        return result;
    }
    ```

22. 취득 메소드 (getter)
    - 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공한다
    - 무작정 취득 메소드를 제공하는 것보다는 가급적 필요한 로직을 데이터가 있는 쪽으로 옮겨라
    - 객체의 가시성을 고려해서 만들어라

23. 설정 메소드 (Setter)
    - 드물게, 메소드를 사용해서 필드 값을 설정한다
    ```java
    paragraph.setJustification(Paragraph.CENTERED); // 이렇게 setter 막 만들어 주지말고
    paragraph.centered() // 이렇게해라
    ```

24. 안전한 복사
    - 접근자 메소드를 통해 전달하거나 전달되는 인스턴스를 복해서 앨리어스 문제를 회피한다