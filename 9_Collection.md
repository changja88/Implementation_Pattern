9. Collection
- 컬렉션의 기본 아이디어는 컬렉션 내부에 있는 객체와 그렇지 않은 객체를 나누는 것뿐이다

1. 메타포
- 여러 값을 가진 변수(Multi-valued variable)
    - 컬렉션 변수는 여러 객체를 한번에 가리키는 역할을 한다

- 객체
    - 자바에서는 컬렉션을 별도의 객체로 취급한다
    
- 수학적 집합
    - 수학에서 집합이 여러 원소의 모임인 것과 마찬가지로 컬렉셔은 객체의 모임이다
    - 집합에 대한 기본적인 연산으로 집합의 크기를 구하는 연산과 집합에 속해있는지 알아보는 속성 테스트를 제공한다

2. 이슈
    - 컬렉션이 표현하는 첫째 개념은 크기이다
        - 배열의 크기는 생성시 고정된다
        - 대부분의 컬렉션은 중간에 크기를 수정할 수 있다
    - 원소간의 순서에 의미가 있는지 여부
    - 원소의 독자성
    - 성능
        - 컬렉션이 너무 커지면, 키를 통해 원소에 접근하는 것이 중요해져서 set이나 map을 사용해야 한다
    
3. 인터페이스
- 배열
    - 가장 단순하지만 가장 유연하지 못한 컬렉션이다. 
    - 크기가 고정 되어 있고 원소 접근 방법이 용이하며 빠르다
    - 배열은 다른 컬렉션과 같은 프로토콜을 갖고 있지 않으므로 배열을 다른 종류의 컬렉션으로 변환하는 일은 복잡하다
    - 배열은 언어 자체에 포함되어 있다는 점에서 라이브러리로 제공되는 다른 컬렉션과는 다른다
    - 단순한 연산의 경우 배열은 다른 컬렉션에 비해 시간, 공간, 모든 면에서 효율적이다

- Iterable
    - 기본적인 컬렉션 인터페이스로 순차 열럼을 지원한다 
    - 다른 기능은 없다
    - Iterable로 선언하는 것은 그 변수가 여러 개의 값을 갖고 있음을 뜻할 뿐이다

- Collection
    - 원소 추가, 제거 및 소속 테스트를 지원한다
    - Iterable을 상속하며, 원소 추가, 삭제, 검색, 크기 측정 등의 메소드를 추가로 지원한다
    - addAll(), retainAll(), removeAll()의 결과로 컬렉션 자체를 바꾸는 대신 새로 할당된 컬렉션을 반환한다

- List
    - 원소의 순서가 정의되어 있으며, 컬렉션상의 위치를 통해 원소에 접근할 수 있다
    - List는 Collection을 기반으로 해서 원소 간에 정해진 순서를 부여한 것이다
    - List를 사용하면 컬렉션상에서의 인덱스를 통해 어떤 원소를 접근 할 수 있다
    - 예를 들어 도착 순서대로 메시지를 처리하는 큐의 경우에는 List를 사용해야 한다

- Set
    - 중복된 원소가 없는 컬렉션
    - 원소를 추가하면 변경된 컬렉션을 반환하는 것이 아니라, 컬렉션 자체가 바뀐다는 점에서 수학접 집합과는 다른다
    - 대부분의 다른 컬렉션에서 지원하는 정보 - 어떤 원소가 몇번 나타나느냐를 지원하지 않는다
      따라서 출현 횟수보다 속해 있는지 여부가 중요할 경우 사용한다
    - 일관된 순서를 지원하지 않기 때문에 원소사이에 상호 작용이 없는 경우에 사용하는 것이 좋ㄷ

- SortedSet
    - 중복 원소가 없으며 원소 간의 순서가 정해진 컬렉션
    - Comparator에 의해서 순서를 정한다 (add하는 순서대로 순서가 정해지지 않는다)

- Map
    - 키에 의해 원소를 저장하고 접근하는 컬렉션
    - List가 정수만을 키로 사용할 수 있는 반면 Map은 임의의 객체를 키로 사용할 수 있다
    - 키는 중복사용 할 수 없지만, 원소는 중복 가능한다
    - 원소의 순서는 보장되지 않는다
    - 단순한 순차 열람자를 요청할 수 없다 
      키에 대한 순차 열람자인지, 데이터에 대한 순차 열람자인지 혹시 쌍에 대한 것인지 알길이 없기 때문

4. 구현
- 컬렉션에 대한 구현 클래스를 선택하는 것은 주로 성능과 관련이 있다
    - Collection
        - Collection 인터페이스에 대한 기본 구현 클래스는 ArrayList이다
        - 컬렉션의 크기에 비례해서 연산 시간이 커지는 제약이 있다 -> 성능 문제가 있다면 HashSet을 고려해봐라
    
    - List
        - Collection 프로토콜에 예측 가능한 원소 사이의 순서를 부여한 것이다
        - 흔히 사용되는 List에 대한 두가지 구현은 ArrayList와 LinkedList이다
    
    - Set
        - HashSet, LinkedHashSet, TreeSet 이 많이 사용된다
        - HashSet은 가장 빠르지만 원소 간의 순서를 보장해주지 않는다
        - LinkedHashSet은 원소 간 순서를 삽압된 순서로 보장해주지만 원소 추가 삭제시 30%정도 더 걸린다
        - TreeSet은 comparator에 따라서 원소를 정렬하지만, 원소 추가 삭제 시간이 logn에 비례해서 커진다
    
    - Map
        - HashMap은 가장 빠르지만 원소 간의 순서를 보장해주지 않는다
        - LinkedHashMap은 원소 간 순서를 삽압된 순서로 보장해주지만 원소 추가 삭제시 30%정도 더 걸린다
        - TreeMap은 comparator에 따라서 원소를 정렬하지만, 원소 추가 삭제 시간이 logn에 비례해서 커진다

5. Collections
- Collections는 다른 컬렉션 인터페이스에 넣기 적절치 않은 기능들을 모아 놓은 유틸리티 클래스 이다. 그 기능들은 다음과 같다
    -  검색
        - indexOf() 연산에 걸리는 시간은 리스트의 크기에 비례한다
    - 정렬
        - 리스트 원소 간의 순서를 바꾸는 연산을 제공한다
    - 수정 불가능한 컬렉션
    - 단일 원소 컬렉션
        - 하나의 원소를 전달해야 하지만 컬렉션 인터페이스를 사용해야 하는 경우
        - Collections.singleton()을 사용할 수 있다
    - 무원소 컬렉션
        - 단일 원소 컬렉션과 유사하게, 컬렉션 인터페이스를 사용해야 하지만 전달할 원가 없는 경우

6. 컬렉션 확장
- 컬렉션과 같은 행위를 지원하기 위해 컬렉션을 화장하는 것에는 몇가지 문제가 있다
- 상속을 하기 보다는 위임을 사용하는 것이 좋다
```java
class Library {
    Collection<Book> books = new ArrayList<Book>();
}
```